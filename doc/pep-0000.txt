PEP:               0000
Title:             Composable futures for reactive programming
Version:           $Revision$
Last-Modified:     $Date$
Author:            Sergiii Mikhtoniuk <mikhtonyuk@gmail.com>
Status:            None
Type:              Standards Track
Content-Type:      text/x-rst
Created:           21-Dec-2013
Python-Version:    3.X
Post-History:

========
Abstract
========

This is a proposal for API improvement of ``concurrent.futures`` which
enables reactive programming in Python. It provides means for 
chaining and combining asynchronous computations without blocking 
to wait for ``Future`` result, offers combination methods for futures, 
allows to control execution context of future calbacks and provides
simpler API for crating and exposing futures in other systems.

==========
Motivation
==========

``Future`` is a well-established facility in many modern languages
for representing asynchronous computations. It is also notable
that many languages have converged into very similar monadic
APIs for ``Futures`` that enable composing computations on top of
results of yet to be completed asynchronous operations without
blocking. This `reactive` style of programming improves resource
utilization which otherwise would be wasted by waiting for async
operations, such as disk and network I/O, to complete.

Current implementation of Python's ``concurrent.futures`` does not 
provide any means for such composition. Current ``Future`` is
basically nothing more than a cancellable and waitable callback.

The power of ``Future`` monad raises with number of standard 
libraries that use it. For example in .Net 4 ``Futures`` (``Tasks``)
were incorporated into most of the APIs exposing asynchronous 
operations such as File I/O, Sockets, Web Requests, LINQ. This
allows to seamlessly combine different async operations together
and easily reason about concurrency models of different systems.

In Python however systems exposing ``Futures`` are limited to
provided ``ThreadPool`` and ``ProcessPool`` executors. Additionally
new libraries such as ``asyncio`` start to emerge having their own
implementations of ``Futures``. This can be contributed to
underdeveloped state of ``concurrent.futures`` which should 
provide the unified implementation.

Proposed solution
-----------------

Proposed imporvements to ``concurrent.futures`` API include:

* Futures composability - extensive set of methods for combining
  chaining and sequencing async computations without blocking or
  leaving ``Future`` monad.

* Simple API for exposing ``Futures`` in your own systems - proposed
  solution is based on proven design of separation of ``Future``
  object representing result of async operation, and ``Promise``
  object representing system's obligation to complete ``Future``
  returned to client at some point of time.

* Restricted scope of implementation - proposed API reduces
  number of restrictions placed on implementations of async
  systems making it more versatile. Specific implementations
  of async schedulers are considered to be out of scope of this
  package, encouraging other modules to provide ``Future`` based
  APIs.

* Greater control of execution context - ability to control
  executor for `Future` callbacks and combination methods.
  This topic was not addressed by original implementation at all.

=============
Specification
=============

Proposed package defines following abstractions:

- ``Executor`` - a contract for scheduling callbacks. It is
  only required for callbacks scheduling and does not
  intended to pose any restrictions on implementations
  of systems exposing async operations.

- ``Future`` - represents result of async operation which is 
  expected to be completed by some ``Executor``.

- ``Promise`` - represents a ``Future`` on the side of the
  async system, it is not exposed to client and is the only
  correct way of setting result to the ``Future``.

Future core interface
---------------------

``Future`` is a client-facing object returned by systems which 
expose asynchronous APIs. Main way to interact with ``Futures``
is to use callbacks and combination methods to chain computations
on top of result that is yet to be returned.

``@property is_completed``

	Returns True if future is completed or cancelled.

``@property is_cancelled``

	Returns True if the future cancellation was requested.

``cancel()``

	Requests cancellation of future. Returns True if future was not
	yet completed or cancelled.

``on_success(fun_res, executor=None)``

	Specified function will be called upon successful future completion.
	fun_res - function that accepts one result argument.
	executor - context to run callback in (default - Synchronous).

``on_failure(fun_ex, executor=None)``

	Specified function will be called upon future failure.
	fun_ex: function that accepts one exception argument.
	executor: context to run callback in (default - Synchronous).

``wait(timeout=None)``

	Blocking wait for future to complete. timeout - time in seconds
	to wait for completion (default - infinite). Returns True if
	future completes within timeout.

``result(timeout=None)``

	Blocking wait for future result. timeout - time in seconds to wait
	for completion (default - infinite). Returns Future result value.

	Raises:
		``TimeoutError``: if future does not complete within timeout.
		``CancelledError``: if future cancellation was requested,
		``Exception``: if future was failed.

	This is one of few ways to drop Future monad, don't use unless it is
	absolutely necessary, prefer future composition.

``exception(timeout=None)``

	Blocking wait for future exception. timeout: time in seconds to wait
	for completion (default - infinite). Returns Exception future failed
	with, including CancelledError, or None if succeeded.
	Raises ``TimeoutError`` if future does not complete within timeout.

	This is one of few ways to drop Future monad, don't use unless it is
	absolutely necessary, prefer future composition.

``@staticmethod successful(result=None, clb_executor=None)``

	Returns successfully completed future. result - value to
	complete future with, clb_executor - default Executor to
	use for running callbacks (default - Synchronous).

``@staticmethod failed(exception, clb_executor=None)``

	Returns failed future. exception - Exception to set to future,
	clb_executor - default Executor to use for running
	callbacks (default - Synchronous).

``@staticmethod completed(fun, *args, clb_executor=None)``

	Returns successful or failed future set from provided function.

Promise interface
-----------------

Promise is an only intended way of creating ``Futures``. It is intended
to be inaccessible to clients of systems which provide async operations
and is the only right way to set result to the future given to client.

``Promise(clb_executor=None)``

	Creates new ``Promise`` with associated ``Future``.
	clb_executor - specifies default ``Executor`` for running
	``Future.on_success()`` and ``Future.on_failure()`` callbacks
	(default - Synchronous).

``@property future``

	Returns associated future instance.

``@property is_completed``

	Returns True if associated future is completed or cancelled.

``@property is_cancelled``

	Returns True if the future cancellation was requested by client.

``success(result)``

	Completes associated future with provided value.
	Raises ``IllegalStateError`` if future value was already set.

``try_success(result)``

	Completes associated future with provided value.
	Returns True if future value was set and False if it was
	already set before.

``failure(exception)``

	Completes associated future with provided exception.
	Raises ``IllegalStateError`` if future value was already set.

``try_failure(exception)``

	Completes associated future with provided exception.
	Returns True if future value was set and False if it was
	already set before.

``complete(fun, *vargs, **kwargs)``

	Executes provided function and sets future value from result
	or exception if function raises.
	Raises ``IllegalStateError`` if future value was already set.

``try_complete(fun, *vargs, **kwargs)``

	Executes provided function and sets future value from result
	or exception if function raises.
	Returns True if future value was set and False if it was
	already set before.

Future composition
------------------

Composition methods allow you to make computations on ``Future``
result without resorting to blocking waits. They also provide
means for combining multiple different futures together.

``recover(fun_ex, executor=None)``

	Returns future that will contain result of original if it
	completes successfully, or set from result of provided function
	in case of failure. fun_ex - function that accepts Exception
	parameter, executor - Executor to use when performing call to
	function (default - Synchronous).

``map(fun_res, executor=None)``

	Returns future which will be set from result of applying
	provided function to original future value. fun_res - function
	that accepts original result and returns new value,
	executor - Executor to use when performing call to
	function (default - Synchronous).

``then(future_fun, executor=None)``

	Returns future which represents two futures chained one
	after another. Failures are propagated from first future,
	from second future and from callback function.
	future_fun - function that returns future to be chained
	after successful completion of first one
	(or Future instance directly), executor - Executor to use
	when performing call to function (default - Synchronous).

``fallback(future_fun, executor=None)``

	Returns future that will contain result of original if
	it completes successfully, or will be set from future
	returned from provided function in case of failure.
	future_fun - function that returns future to be used for
	fallback (or Future instance directly), executor - Executor
	to use when performing call to function (default - Synchronous).

``@staticmethod all(futures, clb_executor=None)``

	Transforms list of futures into one future that will contain
	list of results. In case of any failure future will be failed
	with first exception to occur. futures - list of futures
	to combine, clb_executor - default executor to use when running
	new future's callbacks (default - Synchronous).

``@staticmethod first(futures, clb_executor=None)``

	Returns future which will be set from result of first future
	to complete, both successfully or with failure.
	futures - list of futures to combine, clb_executor - default
	executor to use when running new future's callbacks
	(default - Synchronous).

``@staticmethod first_successful(futures, clb_executor=None)``

	Returns future which will be set from result of first
	future to complete successfully, last detected error
	will be set in case when all of the provided future fail.
	futures - list of futures to combine, clb_executor - default
	executor to use when running new future's callbacks
	(default - Synchronous).

``@staticmethod reduce(futures, fun, *vargs, executor=None, clb_executor=None)``

	Returns future which will be set with reduced result of
	all provided futures. In case of any failure future will
	be failed with first exception to occur. futures - list
	of futures to combine, fun - reduce-compatible function,
	executor - Executor to use when performing call to function
	(default - Synchronous), clb_executor - default executor
	to use when running new future's callbacks
	(default - Synchronous).

Executors
---------

Besides the services which expose asynchronous APIs returning
futures executors appear in many ``Future`` methods to allow
controlling the context in which different callbacks are executed.
Each ``Future`` can be assigned a default callback executor when
created. This allows executors to control suggested context of
callbacks.

For example if a service implements HTTP request multiplexing
in dedicated thread it is dangerous to run user's callbacks
synchronously because they may block or run for considerably
long time, thus blocking the whole HTTP request
processing thread. So this service can override default
callback executor and set it to `ThreadPoolExecutor` when
returning future to client. This way every callback of this
future will run in ThreadPool thread unless it specifies
different executor explicitly.

``Executor`` contract expected by proposed package includes
single method:

``submit(fn, *args, **kwargs)``

	Schedules function for execution and return `Future`
	representing pending result.

By default all futures use ``SynchronousExecutor`` for all
callbacks. This can be changed globally by setting
``config.Default.CALLBACK_EXECUTOR`` field on application
startup, but generally default executor should be controlled
on per-service basis.

Unhandled errors policy
-----------------------

Errors in async operations should not go unnoticed, that's why
proposed package expects that all ``Future`` failures will be
handled explicitly by getting ``result`` or ``exception``,
setting ``on_failure`` callbacks, or using composition methods.

Unhandled error may be result of uncaught exception in ``on_sucess``
or ``on_failure`` callback which is trapped by ``Executor``, or
be raised from ``Future`` who's failure was not handled explicitly.
In later case unhandled error is raised when ``Future`` object is
about to be deleted by GC.

To avoid exceptions being lost package defines default callback
for unhandled failures which logs errors to ``sys.stderr``.
You can override this behavior by setting
``config.Default.UNHANDLED_FAILURE_CALLBACK`` field on application
startup, but avoid ignoring errors. It is always better to
explicitly ignore error of one future by calling
``future.on_failure(None)`` than having bunch of exceptions go
unnoticed.

Performance overhead
--------------------

Overhead of ``Future`` comparing to simple callback is:

- one condition variable for protecting state from concurrent
  access and waiting for completion
- fields for holding future state, result value, and failure
  handling status
- two lists for holding pending ``on_sucess`` and ``on_failure``
  callbacks
- field for default callback executor reference

Since by default callbacks are executed using synchronous
executor, in many cases all overhead is avoided using lightweight
read-only future objects for representing successful and
failed futures.

==============
Usage examples
==============

Completing futures with promises
--------------------------------

::

	from concurrent.futures import Promise
	from threading import Thread
	import time

	def request_blocking(request):
		time.speep(10)
		return request

	def request_async(request):
		p = Promise()
		t = Thread(target=lambda: p.success(request_blocking(request)))
		t.start()
		return p.future

	f = request_async("echo")
	f.on_success(lambda resp: print("response: " + resp))
	f.on_failure(lambda ex: print("request failed"))

Computations
------------

::

	from concurrent.futures import Future
	from concurrent.executors import ThreadPoolExecutor

	with ThreadPoolExecutor(10) as tp:
		def sqr(x):
			return x * x

		fsquares = [tp.submit(sqr, v) for v in range(10)]
		fsum = Future.all(fsquares).map(sum)

		print(fsum.result())

Chaining requests
-----------------

::

	from concurrent.futures import Future

	def authenticate_async(login, pwd):
		return Future.successful(True)

	def request_async(request):
		return Future.successful(request)

	fauth = authenticate_async('john', 'swordfish')
	frequest = fauth.then(lambda: request_async('echo'))

	frequest.on_success(lambda resp: print("auth and request successful: " + resp))
	frequest.on_failure(lambda ex: print("auth or request failed"))


Fallbacks
---------

::

	from concurrent.futures import Future

	def connect_ssl():
		return Future.failed(SocketError())

	def connect_plain():
		return Future.successful('socket')

	fconnection = connect_ssl().fallback(connect_plain)

Hedged requests
---------------

::

	from concurrent.futures import Future
	from concurrent.executors import ThreadPoolExecutor
	import random
	import time

	def request(ip):
		time.sleep(random.random())
		if random.choice([True, False]):
			return "ok"
		raise Exception("fail")

	with ThreadPoolExecutor(10) as tp:
		IPs = ['ip1', 'ip2', 'ip3', 'ip4', 'ip5']
		futures = [tp.submit(request, ip) for ip in IPs]
		fresponse = Future.first_successful(futures)

		print(fresponse.result())

======================
Backward compatibility
======================

Interface differences
---------------------

Executor interface reduced to:

::

	class Executor:
		def submit(fn, *args, **kwargs) -> Future

Future interface differences:

``cancel()``

	Method return value does not relate to state of execution
	of async operation. Communicating cancellation to executors
	of async operations may be too restrictive for some
	implementations and can cause unwanted blocking. Instead
	cancel method returns True when future is not yet completed
	and cancelled state was successfully set (similarly to
	`Promise.try_failure()`). Using `Promise.is_cancelled()`
	executor of async operation can then periodically check
	whether future's result is still expected.

``cancelled()``

	Method replaced with `is_cancelled` property

``running()``

	Method removed as too restrictive for some implementations,
	not useful, and encouraging bad design.

``done()``

	Method replaced with `is_completed` property

``exception()``

	Method does not raise `CancelledError` but returns it instead
	to unify the error handling logic.

``set_running_or_notify_cancel()``
``set_result()``
``set_exception()``

	Methods for future completion removed in favour of using `Promise`.

Module functions differences:

``wait()``
``as_completed()``

	Functions removed to encourage use of future composition.
	`Future.result()` and `Future.exception()` are only ways
	to drop `Future` monad.

Concrete implementations of executor are considered to be beyond the 
scope of ``concurrent.futures`` module, but for backward compatibility
implementations of ``ThreadPoolExecutor`` and ``ProcessPoolExecutor``
remain and return new futures, but will be deprecated. Other modules
such as ``threading`` and ``multipocessing`` are more logical place
for this functionality.

==========
References
==========

- PEP 3148 describes current implementation of ``concurrent.futures``
- PEP 3156 describes ``asyncio`` package implementing own futures

