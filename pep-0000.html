<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">0000</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Composable futures for reactive programming</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-0000.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Sergiii Mikhtoniuk &lt;mikhtonyuk&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">None</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Dec-2013</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a><ul>
<li><a class="reference internal" href="#proposed-solution" id="id3">Proposed solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a><ul>
<li><a class="reference internal" href="#future-core-interface" id="id5">Future core interface</a></li>
<li><a class="reference internal" href="#promise-interface" id="id6">Promise interface</a></li>
<li><a class="reference internal" href="#future-composition" id="id7">Future composition</a></li>
<li><a class="reference internal" href="#executors" id="id8">Executors</a></li>
<li><a class="reference internal" href="#unhandled-errors-policy" id="id9">Unhandled errors policy</a></li>
<li><a class="reference internal" href="#performance-and-overhead" id="id10">Performance and overhead</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-compatibility" id="id11">Backward compatibility</a><ul>
<li><a class="reference internal" href="#interface-differences" id="id12">Interface differences</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<ul class="simple">
<li>concurrent.futures not composable</li>
<li>escaping monad</li>
<li>multiple versions (asyncio)</li>
<li>benefit</li>
<li>callback execution context</li>
</ul>
<div class="section" id="proposed-solution">
<h2><a class="toc-backref" href="#id3">Proposed solution</a></h2>
<ul class="simple">
<li>composability</li>
<li>easy to use for other impls</li>
<li>focused</li>
<li>no thread pools etc</li>
</ul>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Proposed package defines following abstractions:</p>
<ul class="simple">
<li><cite>Executor</cite> - a contract for scheduling async operations.</li>
<li><cite>Future</cite> - represents result of async operation which is expected to be completed by some <cite>Executor</cite></li>
<li><cite>Promise</cite> - represents a <cite>Future</cite> on the <cite>Executor</cite> side, it is not exposed to client and is the only correct way of setting result to <cite>Future</cite>.</li>
</ul>
<div class="section" id="future-core-interface">
<h2><a class="toc-backref" href="#id5">Future core interface</a></h2>
<p><tt class="docutils literal">&#64;property is_completed</tt></p>
<blockquote>
Returns True if future is completed or cancelled.</blockquote>
<p><tt class="docutils literal">&#64;property is_cancelled</tt></p>
<blockquote>
Returns True if the future cancellation was requested.</blockquote>
<p><tt class="docutils literal">cancel()</tt></p>
<blockquote>
Requests cancellation of future. Returns True if future was not
yet completed or cancelled.</blockquote>
<p><tt class="docutils literal">on_success(fun_res, executor=None)</tt></p>
<blockquote>
Specified function will be called upon successful future completion.
fun_res - function that accepts one result argument.
executor - context to run callback in (default - Synchronous).</blockquote>
<p><tt class="docutils literal">on_failure(fun_ex, executor=None)</tt></p>
<blockquote>
Specified function will be called upon future failure.
fun_ex: function that accepts one exception argument.
executor: context to run callback in (default - Synchronous).</blockquote>
<p><tt class="docutils literal">wait(timeout=None)</tt></p>
<blockquote>
Blocking wait for future to complete. timeout - time in seconds
to wait for completion (default - infinite). Returns True if
future completes within timeout.</blockquote>
<p><tt class="docutils literal">result(timeout=None)</tt></p>
<blockquote>
<p>Blocking wait for future result. timeout - time in seconds to wait
for completion (default - infinite). Returns Future result value.</p>
<dl class="docutils">
<dt>Raises:</dt>
<dd><tt class="docutils literal">TimeoutError</tt>: if future does not complete within timeout.
<tt class="docutils literal">CancelledError</tt>: if future cancellation was requested,
<tt class="docutils literal">Exception</tt>: if future was failed.</dd>
</dl>
<p>This is one of few ways to drop Future monad, don't use unless it is
absolutely necessary, prefer future composition.</p>
</blockquote>
<p><tt class="docutils literal">exception(timeout=None)</tt></p>
<blockquote>
<p>Blocking wait for future exception. timeout: time in seconds to wait
for completion (default - infinite). Returns Exception future failed
with, including CancelledError, or None if succeeded.
Raises <tt class="docutils literal">TimeoutError</tt> if future does not complete within timeout.</p>
<p>This is one of few ways to drop Future monad, don't use unless it is
absolutely necessary, prefer future composition.</p>
</blockquote>
</div>
<div class="section" id="promise-interface">
<h2><a class="toc-backref" href="#id6">Promise interface</a></h2>
<p>Promise is an only intended way of creating <tt class="docutils literal">Futures</tt>. It is intended
to be inaccessible to clients of services which provide async operations
and is the only right way to set result to the future given to client.</p>
<p><tt class="docutils literal">Promise(clb_executor=None)</tt></p>
<blockquote>
Creates new <tt class="docutils literal">Promise</tt> with associated <tt class="docutils literal">Future</tt>.
clb_executor - specifies default <tt class="docutils literal">Executor</tt> for running
<tt class="docutils literal">Future.on_success()</tt> and <tt class="docutils literal">Future.on_failure()</tt> callbacks
(default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;property is_completed</tt></p>
<blockquote>
Returns True if associated future is completed or cancelled.</blockquote>
<p><tt class="docutils literal">&#64;property is_cancelled</tt></p>
<blockquote>
Returns True if the future cancellation was requested by client.</blockquote>
<p><tt class="docutils literal">&#64;property future</tt></p>
<blockquote>
Returns associated future instance.</blockquote>
<p><tt class="docutils literal">success(result)</tt></p>
<blockquote>
Completes associated future with provided value.
Raises <tt class="docutils literal">IllegalStateError</tt> if future value was already set.</blockquote>
<p><tt class="docutils literal">try_success(result)</tt></p>
<blockquote>
Completes associated future with provided value.
Returns True if future value was set and False if it was
already set before.</blockquote>
<p><tt class="docutils literal">failure(exception)</tt></p>
<blockquote>
Completes associated future with provided exception.
Raises <tt class="docutils literal">IllegalStateError</tt> if future value was already set.</blockquote>
<p><tt class="docutils literal">try_failure(exception)</tt></p>
<blockquote>
Completes associated future with provided exception.
Returns True if future value was set and False if it was
already set before.</blockquote>
<p><tt class="docutils literal">complete(fun, *vargs, **kwargs)</tt></p>
<blockquote>
Executes provided function and sets future value from result
or exception if function raises.
Raises <tt class="docutils literal">IllegalStateError</tt> if future value was already set.</blockquote>
<p><tt class="docutils literal">try_complete(fun, *vargs, **kwargs)</tt></p>
<blockquote>
Executes provided function and sets future value from result
or exception if function raises.
Returns True if future value was set and False if it was
already set before.</blockquote>
</div>
<div class="section" id="future-composition">
<h2><a class="toc-backref" href="#id7">Future composition</a></h2>
<p><tt class="docutils literal">&#64;staticmethod successful(result=None, clb_executor=None)</tt></p>
<blockquote>
Returns successfully completed future. result - value to
complete future with, clb_executor - default Executor to
use for running callbacks (default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod failed(exception, clb_executor=None)</tt></p>
<blockquote>
Returns failed future. exception - Exception to set to future,
clb_executor - default Executor to use for running
callbacks (default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod completed(fun, *args, clb_executor=None)</tt></p>
<blockquote>
Returns successful or failed future set from provided function.</blockquote>
<p><tt class="docutils literal">recover(fun_ex, executor=None)</tt></p>
<blockquote>
Returns future that will contain result of original if it
completes successfully, or set from result of provided function
in case of failure. fun_ex - function that accepts Exception
parameter, executor - Executor to use when performing call to
function (default - Synchronous).</blockquote>
<p><tt class="docutils literal">map(fun_res, executor=None)</tt></p>
<blockquote>
Returns future which will be set from result of applying
provided function to original future value. fun_res - function
that accepts original result and returns new value,
executor - Executor to use when performing call to
function (default - Synchronous).</blockquote>
<p><tt class="docutils literal">then(future_fun, executor=None)</tt></p>
<blockquote>
Returns future which represents two futures chained one
after another. Failures are propagated from first future,
from second future and from callback function.
future_fun - function that returns future to be chained
after successful completion of first one
(or Future instance directly), executor - Executor to use
when performing call to function (default - Synchronous).</blockquote>
<p><tt class="docutils literal">fallback(future_fun, executor=None)</tt></p>
<blockquote>
Returns future that will contain result of original if
it completes successfully, or will be set from future
returned from provided function in case of failure.
future_fun - function that returns future to be used for
fallback (or Future instance directly), executor - Executor
to use when performing call to function (default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod all(futures, clb_executor=None)</tt></p>
<blockquote>
Transforms list of futures into one future that will contain
list of results. In case of any failure future will be failed
with first exception to occur. futures - list of futures
to combine, clb_executor - default executor to use when running
new future's callbacks (default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod first(futures, clb_executor=None)</tt></p>
<blockquote>
Returns future which will be set from result of first future
to complete, both successfully or with failure.
futures - list of futures to combine, clb_executor - default
executor to use when running new future's callbacks
(default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod first_successful(futures, clb_executor=None)</tt></p>
<blockquote>
Returns future which will be set from result of first
future to complete successfully, last detected error
will be set in case when all of the provided future fail.
futures - list of futures to combine, clb_executor - default
executor to use when running new future's callbacks
(default - Synchronous).</blockquote>
<p><tt class="docutils literal">&#64;staticmethod reduce(futures, fun, *vargs, executor=None, clb_executor=None)</tt></p>
<blockquote>
Returns future which will be set with reduced result of
all provided futures. In case of any failure future will
be failed with first exception to occur. futures - list
of futures to combine, fun - reduce-compatible function,
executor - Executor to use when performing call to function
(default - Synchronous), clb_executor - default executor
to use when running new future's callbacks
(default - Synchronous).</blockquote>
</div>
<div class="section" id="executors">
<h2><a class="toc-backref" href="#id8">Executors</a></h2>
<p>Besides the services which expose asynchronous APIs returning
futures executors appear in many <cite>Future</cite> methods to allow
controlling the context in which different callbacks are executed.
Each <cite>Future</cite> can be assigned a default callback executor when
created. This allows executors to control suggested context of
callbacks.</p>
<p>For example if a service implements HTTP request multiplexing
in dedicated thread it is dangerous to run user's callbacks
synchronously because they may block or run for considerably
long time, thus blocking the whole HTTP request
processing thread. So this service can override default
callback executor and set it to <cite>ThreadPoolExecutor</cite> when
returning future to client. This way every callback of this
future will run in ThreadPool thread unless it specifies
different executor explicitly.</p>
<p><cite>Executor</cite> contract expected by proposed package includes
single method:</p>
<p><tt class="docutils literal">submit(fn, *args, **kwargs)</tt></p>
<blockquote>
Schedules function for execution and return <cite>Future</cite>
representing pending result.</blockquote>
<p>By default all futures use <cite>SynchronousExecutor</cite> for all
callbacks. This can be changed globally by setting
<cite>config.Default.CALLBACK_EXECUTOR</cite> field on application
startup, but generally default executor should be controlled
on per-service basis.</p>
</div>
<div class="section" id="unhandled-errors-policy">
<h2><a class="toc-backref" href="#id9">Unhandled errors policy</a></h2>
<p>Errors in async operations should not go unnoticed, that's why
proposed package expects that all <cite>Future</cite> failures will be
handled explicitly by getting <cite>result</cite> or <cite>exception</cite>,
setting <cite>on_failure</cite> callbacks, or using composition methods.</p>
<p>Unhandled error may be result of uncaught exception in <cite>on_sucess</cite>
or <cite>on_failure</cite> callback which is trapped by <cite>Executor</cite>, or
be raised from <cite>Future</cite> who's failure was not handled explicitly.
In later case unhandled error is raised when <cite>Future</cite> object is
about to be deleted by GC.</p>
<p>To avoid exceptions being lost package defines default callback
for unhandled failures which logs errors to <cite>sys.stderr</cite>.
You can override this behavior by setting
<cite>config.Default.UNHANDLED_FAILURE_CALLBACK</cite> field on application
startup, but avoid ignoring errors. It is always better to
explicitly ignore error of one future by calling
<cite>future.on_failure(None)</cite> than having bunch of exceptions go
unnoticed.</p>
</div>
<div class="section" id="performance-and-overhead">
<h2><a class="toc-backref" href="#id10">Performance and overhead</a></h2>
<p>Overhead of <cite>Future</cite> comparing to simple callback is:</p>
<ul class="simple">
<li>one condition variable for protecting state from concurrent
access and waiting for completion</li>
<li>fields for holding future state, result value, and failure
handling status</li>
<li>two lists for holding pending <cite>on_sucess</cite> and <cite>on_failure</cite>
callbacks</li>
<li>field for default callback executor reference</li>
</ul>
<p>Since by default callbacks are executed using synchronous
executor, in many cases all overhead is avoided using lightweight
read-only future objects for representing successful and
failed futures.</p>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id11">Backward compatibility</a></h1>
<div class="section" id="interface-differences">
<h2><a class="toc-backref" href="#id12">Interface differences</a></h2>
<p>Executor interface reduced to:</p>
<pre class="literal-block">
class Executor:
        def submit(fn, *args, **kwargs) -&gt; Future
</pre>
<p>Future interface:</p>
<p><tt class="docutils literal">cancel()</tt></p>
<blockquote>
Method return value does not relate to state of execution
of async operation. Communicating cancellation to executors
of async operations may be too restrictive for some
implementations and can cause unwanted blocking. Instead
cancel method returns True when future is not yet completed
and cancelled state was successfully set (similarly to
<cite>Promise.try_failure()</cite>). Using <cite>Promise.is_cancelled()</cite>
executor of async operation can then periodically check
whether future's result is still expected.</blockquote>
<p><tt class="docutils literal">cancelled()</tt></p>
<blockquote>
Method replaced with <cite>is_cancelled</cite> property</blockquote>
<p><tt class="docutils literal">running()</tt></p>
<blockquote>
Method removed as too restrictive for some implementations,
not useful, and encouraging bad design.</blockquote>
<p><tt class="docutils literal">done()</tt></p>
<blockquote>
Method replaced with <cite>is_completed</cite> property</blockquote>
<p><tt class="docutils literal">exception()</tt></p>
<blockquote>
Method does not raise <cite>CancelledError</cite> but returns it instead
to unify the error handling logic.</blockquote>
<p><tt class="docutils literal">set_running_or_notify_cancel()</tt>
<tt class="docutils literal">set_result()</tt>
<tt class="docutils literal">set_exception()</tt></p>
<blockquote>
Methods for future completion removed in favour of using <cite>Promise</cite>.</blockquote>
<p>Module functions:</p>
<p><tt class="docutils literal">wait()</tt>
<tt class="docutils literal">as_completed()</tt></p>
<blockquote>
Functions removed to encourage use of future composition.
<cite>Future.result()</cite> and <cite>Future.exception()</cite> are only ways
to drop <cite>Future</cite> monad.</blockquote>
</div>
</div>

