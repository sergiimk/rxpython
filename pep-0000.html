<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">0000</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Unifying Future implementations</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-0000.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Sergii Mikhtoniuk &lt;mikhtonyuk&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">None</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Dec-2013</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.X</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a><ul>
<li><a class="reference internal" href="#proposed-solution" id="id3">Proposed Solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a><ul>
<li><a class="reference internal" href="#future-type-hierarchy" id="id5">Future type hierarchy</a></li>
<li><a class="reference internal" href="#futurebase-interface" id="id6">FutureBase interface</a></li>
<li><a class="reference internal" href="#futurebaseext-interface" id="id7">FutureBaseExt interface</a></li>
<li><a class="reference internal" href="#cooperative-future-interface" id="id8">cooperative.Future interface</a></li>
<li><a class="reference internal" href="#multithreaded-future-interface" id="id9">multithreaded.Future interface</a></li>
<li><a class="reference internal" href="#executors" id="id10">Executors</a></li>
<li><a class="reference internal" href="#unhandled-errors-policy" id="id11">Unhandled errors policy</a></li>
<li><a class="reference internal" href="#compatibility-between-different-types-of-futures" id="id12">Compatibility between different types of futures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usage-examples" id="id13">Usage examples</a><ul>
<li><a class="reference internal" href="#computations" id="id14">Computations</a></li>
<li><a class="reference internal" href="#chaining-requests" id="id15">Chaining requests</a></li>
<li><a class="reference internal" href="#fallbacks" id="id16">Fallbacks</a></li>
<li><a class="reference internal" href="#hedged-requests" id="id17">Hedged requests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-compatibility" id="id18">Backward compatibility</a><ul>
<li><a class="reference internal" href="#interface-differences" id="id19">Interface differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#further-development" id="id20">Further development</a></li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This is a proposal for unification of Future classes of <tt class="docutils literal">concurrent.futures</tt> and <tt class="docutils literal">asyncio</tt> packages which currently have similar interfaces but are completely unrelated types.</p>
<p>This proposal includes:</p>
<ul class="simple">
<li>implementing Future class hierarchy with two leaf classes for <tt class="docutils literal">cooperative</tt> and <tt class="docutils literal">multithreaded</tt> concurrency scenarios</li>
<li>making <tt class="docutils literal">asyncio.Future</tt> a concrete implementation of cooperative concurrency future</li>
<li>providing common set of futures composition methods</li>
<li>unifying callback scheduling mechanism</li>
<li>unifying error handling strategy</li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<p><tt class="docutils literal">Future</tt> is an abstraction for representing result of asynchronous operation. It is independent of the specific way asynchronous operation is performed, whether it is by means of multithreading or using coroutine-based cooperative concurrency.</p>
<p>Currently standard Python library has two <tt class="docutils literal">Future</tt> types for cooperative and multithreaded concurrency: <tt class="docutils literal">concurrent.futures.Future</tt> and <tt class="docutils literal">asyncio.Future</tt> respectively. These types have similar interfaces, but they are completely unrelated.</p>
<p>As a consequence:</p>
<ul class="simple">
<li>It is hard to reason about interoperability of code with different concurrency models.</li>
<li>Implementing computations on futures in concurrency-agnostic way is highly error-prone as implementation needs to rely soley on callbacks and duck-typing.</li>
<li>Implementations have different error handling strategies.</li>
<li>Composition methods such as <tt class="docutils literal">concurrent.futures.wait</tt> and <tt class="docutils literal">asyncio.wait</tt> are duplicated for different types of futures.</li>
<li>Cooperative concurrency <tt class="docutils literal">Future</tt> is tightly coupled with <tt class="docutils literal">asyncio</tt> package.</li>
<li><tt class="docutils literal">concurrent.future.Future</tt> is tightly coupled to provided executors.</li>
</ul>
<div class="section" id="proposed-solution">
<h2><a class="toc-backref" href="#id3">Proposed Solution</a></h2>
<p>Proposed solution includes:</p>
<ul class="simple">
<li>Bringing cooperative and multithreaded futures under single type hierarchy.</li>
<li>Defining <tt class="docutils literal">concurrent.futures.cooperative.Future</tt> class for cooperative concurrency scenario, preserving interface of current <tt class="docutils literal">asyncio.Future</tt> (purely callback-based, without any blocking methods).</li>
<li>Defining <tt class="docutils literal">concurrent.futures.multithreaded.Future</tt> class which ensures thread-safety of core <tt class="docutils literal">Future</tt> state and adds blocking operations.</li>
<li>Implementing common unhandled error policy and callback scheduling mechanism.</li>
<li>Subclassing <tt class="docutils literal">asyncio.Future</tt> from <tt class="docutils literal">cooperative.Future</tt> while adding only methods specific to <tt class="docutils literal">yield from</tt>.</li>
<li>Implementing <tt class="docutils literal">concurrent.futures.Future</tt> in terms of <tt class="docutils literal">concurrent.futures.multithreaded.Future</tt> for backward-compatibility, while deprecating its use (especially discouraging use of <tt class="docutils literal">running()</tt> and <tt class="docutils literal">set_running_or_notify_cancel()</tt> methods as posing to much restrictions on scheduler implementations).</li>
<li>Implementing common set of <tt class="docutils literal">Future</tt> composition methods (such as <tt class="docutils literal">all()</tt>, <tt class="docutils literal">first()</tt>, <tt class="docutils literal">first_sucessful()</tt> etc.).</li>
</ul>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Proposed package defines following abstractions:</p>
<ul class="simple">
<li><tt class="docutils literal">Future</tt> - represents result of async operation, which is expected to be completed by some async system.</li>
<li><tt class="docutils literal">Executor</tt> - a callable object used for scheduling callbacks. For example in cooperative concurrency scenario this can be <tt class="docutils literal">event_loop.call_soon()</tt> method, and for multithreaded case it can be either <tt class="docutils literal">thread pool</tt> for scheduling callbacks on different thread), or <tt class="docutils literal">Synchronous</tt> scheduler for running callback in same context as processing (if acceptable).</li>
</ul>
<div class="section" id="future-type-hierarchy">
<h2><a class="toc-backref" href="#id5">Future type hierarchy</a></h2>
<p><tt class="docutils literal">Future</tt> type hierarchy in package <tt class="docutils literal">concurrent.futures</tt> consists of:</p>
<ul class="simple">
<li><tt class="docutils literal">FutureBase</tt> class, implementing core <tt class="docutils literal">Future</tt> state handling, as well as callback maintenance and invocation.</li>
<li><tt class="docutils literal">FutureBaseExt</tt> class, inherits <tt class="docutils literal">FutureBase</tt> and adds composition and convenience methods on top of <tt class="docutils literal">FutureBase</tt> interface.</li>
<li><tt class="docutils literal">cooperative.Future</tt> class, inherits <tt class="docutils literal">FutureBaseExt</tt> and playing role as base class for all cooperative concurrency <tt class="docutils literal">Future</tt> implementations (such as <tt class="docutils literal">asyncio.Future</tt>).</li>
<li><tt class="docutils literal">multithreaded.Future</tt> class, inherits <tt class="docutils literal">FutureBaseExt</tt> and serves basic implementation for <tt class="docutils literal">Futures</tt> used in multithreaded scenarios. It adds ability to for blocking on <tt class="docutils literal">result()</tt> and <tt class="docutils literal">exception()</tt> methods with configurable timeout.</li>
</ul>
</div>
<div class="section" id="futurebase-interface">
<h2><a class="toc-backref" href="#id6">FutureBase interface</a></h2>
<p><tt class="docutils literal">FutureBase</tt> is a common interface between futures of all concurrency models. It only exposes callback subscription as a primary way of handling <tt class="docutils literal">Future</tt> results.</p>
<p><tt class="docutils literal">FutureBase</tt> interface is the same as of current implementation of <tt class="docutils literal">asyncio.Future</tt>, with the exception of new <tt class="docutils literal">try_set_*</tt> convenience methods.</p>
<p><tt class="docutils literal"><span class="pre">__init__(*,</span> clb_executor=None)</tt></p>
<blockquote>
<p>Initializes future instance.</p>
<p><tt class="docutils literal">clb_executor</tt> specifies default executor object for scheduling callbacks (by default set from <tt class="docutils literal">config.Default.CALLBACK_EXECUTOR</tt>)</p>
</blockquote>
<p><tt class="docutils literal">add_done_callback(fun_res, *, executor=None)</tt></p>
<blockquote>
<p>Add a callback to be run when the future becomes done.</p>
<p>The callback is called with a single argument - the future object. If the future is already done when this is called, the callback is scheduled with call_soon.</p>
</blockquote>
<p><tt class="docutils literal">remove_done_callback(fn)</tt></p>
<blockquote>
<p>Remove all instances of a callback from the &quot;call when done&quot; list.</p>
<p>Returns the number of callbacks removed.</p>
</blockquote>
<p><tt class="docutils literal">cancelled()</tt></p>
<blockquote>
Return True if the future was cancelled.</blockquote>
<p><tt class="docutils literal">done()</tt></p>
<blockquote>
<p>Return True if the future is done.</p>
<p>Done means either that a result / exception are available, or that the future was cancelled.</p>
</blockquote>
<p><tt class="docutils literal">result()</tt></p>
<blockquote>
<p>Return the result this future represents.</p>
<p>If the future has been cancelled, raises CancelledError. If the future's result isn't yet available, raises InvalidStateError. If the future is done and has an exception set, this exception is raised.</p>
</blockquote>
<p><tt class="docutils literal">exception()</tt></p>
<blockquote>
<p>Return the exception that was set on this future.</p>
<p>The exception (or None if no exception was set) is returned only if the future is done.  If the future has been cancelled, raises CancelledError.  If the future isn't done yet, raises
InvalidStateError.</p>
</blockquote>
<p><tt class="docutils literal">cancel()</tt></p>
<blockquote>
<p>Cancel the future and schedule callbacks.</p>
<p>If the future is already done or cancelled, return False.  Otherwise, change the future's state to cancelled, schedule the callbacks and return True.</p>
</blockquote>
<p><tt class="docutils literal">set_result(result)</tt></p>
<blockquote>
<p>Mark the future done and set its result.</p>
<p>If the future is already done when this method is called, raises InvalidStateError.</p>
</blockquote>
<p><tt class="docutils literal">try_set_result(result)</tt></p>
<blockquote>
<p>Attempts to mark the future done and set its result.</p>
<p>Returns False if the future is already done when this method is called.</p>
</blockquote>
<p><tt class="docutils literal">set_exception(exception)</tt></p>
<blockquote>
<p>Mark the future done and set an exception.</p>
<p>If the future is already done when this method is called, raises InvalidStateError.</p>
</blockquote>
<p><tt class="docutils literal">try_set_exception(exception)</tt></p>
<blockquote>
<p>Attempts to mark the future done and set an exception.</p>
<p>Returns False if the future is already done when this method is called.</p>
</blockquote>
<p><tt class="docutils literal">set_from(other)</tt></p>
<blockquote>
<p>Copies result of another future into this one.</p>
<p>Copies either result, exception, or cancelled state depending on how other future was completed.</p>
<p>If this future is already done when this method is called, raises InvalidStateError. Other future should be done() before making this call.</p>
</blockquote>
<p><tt class="docutils literal">try_set_from(other)</tt></p>
<blockquote>
<p>Copies result of another future into this one.</p>
<p>Copies either result, exception, or cancelled state depending on how other future was completed.</p>
<p>Returns False if this future is already done when this method is called. Other future should be done() before making this call.</p>
</blockquote>
</div>
<div class="section" id="futurebaseext-interface">
<h2><a class="toc-backref" href="#id7">FutureBaseExt interface</a></h2>
<p><tt class="docutils literal">FutureBaseExt</tt> class adds various composition and convenience methods on top of <tt class="docutils literal">FutureBase</tt> interface.</p>
<p>Composition methods allow making simple computations on <tt class="docutils literal">Future</tt> result without resorting to blocking (with either <tt class="docutils literal">yield from</tt> or timeouts). They also provide
means for combining multiple different futures together.</p>
<p><tt class="docutils literal">recover(fun_ex_or_value, executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future that will contain result of original if it completes successfully, or set from result of provided function in case of failure. New future inherits default callback executor from original future. Propagates exceptions from function as well as cancellation.</p>
<p>fun_ex_or_value: function that accepts Exception parameter or just value to use in error case.
parameter, executor - Executor to use when performing call to function.</p>
</blockquote>
<p><tt class="docutils literal">map(fun_res, executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future which will be set from result of applying provided function to original future value. New future inherits default callback executor from original future. Propagates exceptions from function as well as cancellation.</p>
<p>fun_res - function that accepts original result and returns new value,
executor - Executor to use when performing call to function.</p>
</blockquote>
<p><tt class="docutils literal">then(future_fun, executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future which represents two futures chained one after another. Failures are propagated from first future, from second future and from callback function. Cancellation is propagated both ways.</p>
<p>future_fun - either function that returns future to be chained after successful completion of first one, or Future instance directly.
executor - Executor to use when performing call to function.</p>
</blockquote>
<p><tt class="docutils literal">fallback(future_fun, executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future that will contain result of original if it completes successfully, or will be set from future returned from provided function in case of failure. Provided function is called only if original future fails. Cancellation is propagated both ways.</p>
<p>future_fun - either function that returns future to be used for fallback, or Future instance directly.
executor - Executor to use when performing call to function.</p>
</blockquote>
<p><tt class="docutils literal">&#64;classmethod all(futures, clb_executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Transforms list of futures into one future that will contain list of results. In case of any failure future will be failed with first exception to occur. Cancellation is propagated both ways - if aggregate future is cancelled it will cancel all child futures.</p>
<p>futures - list of futures to combine
clb_executor - default executor to use when running new future's callbacks.</p>
</blockquote>
<p><tt class="docutils literal">&#64;classmethod first(futures, clb_executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future which will be set from result of first future to complete, both successfully or with failure. Cancellation is propagated both ways - if aggregate future is cancelled it will cancel all child futures.</p>
<p>futures - list of futures to combine.
clb_executor - default executor to use when running new future's callbacks.</p>
</blockquote>
<p><tt class="docutils literal">&#64;classmethod first_successful(futures, clb_executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future which will be set from result of first future to complete successfully, last detected error will be set in case when all of the provided future fail. In case of cancelling aggregate future all child futures will be cancelled. Only cancellation of all child future triggers cancellation of aggregate future.</p>
<p>futures - list of futures to combine.
clb_executor - default executor to use when running new future's callbacks.</p>
</blockquote>
<p><tt class="docutils literal">&#64;classmethod reduce(futures, fun, *vargs, executor=None, clb_executor=None) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Returns future which will be set with reduced result of all provided futures. In case of any failure future will be failed with first exception to occur. Cancellation is propagated both ways - if aggregate future is cancelled it will cancel all child futures.</p>
<p>futures - list of futures to combine, fun - reduce-compatible function.
executor - Executor to use when performing call to function.
clb_executor - default executor to use when running new future's callbacks.</p>
</blockquote>
<p><tt class="docutils literal">&#64;classmethod convert(future) <span class="pre">-&gt;</span> Future</tt></p>
<blockquote>
<p>Performs future type conversion.</p>
<p>It either makes sure that passed future is safe to use with current
future type, or raises TypeError indicating incompatibility.</p>
<p>Override this method in leaf future classes to enable
compatibility between different Future implementations.</p>
</blockquote>
</div>
<div class="section" id="cooperative-future-interface">
<h2><a class="toc-backref" href="#id8">cooperative.Future interface</a></h2>
<p><tt class="docutils literal">cooperative.Future</tt> inherits <tt class="docutils literal">FutureBaseExt</tt> and does not have any additional operations. Its only purpose is to separate concurrent and multithreaded branches of hierarchy.</p>
</div>
<div class="section" id="multithreaded-future-interface">
<h2><a class="toc-backref" href="#id9">multithreaded.Future interface</a></h2>
<p><tt class="docutils literal">multithreaded.Future</tt> adds thread-safety and blocking operations to <tt class="docutils literal">FutureBase</tt> methods.</p>
<p><tt class="docutils literal"><span class="pre">result(*,</span> timeout=None)</tt></p>
<blockquote>
<p>Return the result this future represents. If the future has not yet been completed this method blocks for up to timeout seconds. If timeout is not specified it will block for unlimited time.</p>
<p>If the future has been cancelled, raises CancelledError. If the future does not complete in specified time frame, raises TimeoutError. If the future is done and has an exception set, this exception is raised.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">exception(*,</span> timeout=None)</tt></p>
<blockquote>
<p>Return the exception that was set on this future. If the future has not yet been completed this method blocks for up to timeout seconds. If timeout is not specified it will block for unlimited time.</p>
<p>If the future has been cancelled, raises CancelledError. If the future does not complete in specified time frame, raises TimeoutError.</p>
</blockquote>
</div>
<div class="section" id="executors">
<h2><a class="toc-backref" href="#id10">Executors</a></h2>
<p><tt class="docutils literal">Future</tt> API allows two ways of specifying execution context for callbacks. First is by setting default callback executor on <tt class="docutils literal">Future</tt> creation. Second is by specifying it on per-callback basis when registering the callback.</p>
<p>Controlling default callback context may be necessary for some services. For example if a service implements HTTP request multiplexing in dedicated thread, it's dangerous to run user's callbacks synchronously, because they may block or run for considerably long time. Such behavior would block the whole HTTP request processing thread. Such services can override default callback executor and set it to, for example, to <tt class="docutils literal">ThreadPoolExecutor</tt> when returning future to client. This way every callback of this future will run in <tt class="docutils literal">ThreadPool</tt> thread unless user specifies different executor explicitly.</p>
<p><tt class="docutils literal">Executor</tt> is a callable object that receives function to execute:</p>
<p><tt class="docutils literal">__call__(fn, *args, **kwargs)</tt></p>
<blockquote>
Schedules function for execution.</blockquote>
<p>By default all futures use <tt class="docutils literal">SynchronousExecutor</tt> for all callbacks. This can be changed globally by setting <tt class="docutils literal">config.Default.CALLBACK_EXECUTOR</tt> field on application startup, but generally default executor should be controlled on per-service basis.</p>
</div>
<div class="section" id="unhandled-errors-policy">
<h2><a class="toc-backref" href="#id11">Unhandled errors policy</a></h2>
<p>Errors in async operations should not go unnoticed, that's why proposed package expects that all <tt class="docutils literal">Future</tt> failures will be handled explicitly by callbacks, by getting <tt class="docutils literal">result</tt> or <tt class="docutils literal">exception</tt>, or by use of composition methods. Unhandled error is detected when <tt class="docutils literal">Future</tt> object is about to be deleted by GC, and none of the above methods were used to detect the exception. Unhandled error may also be result of uncaught exception in the callback itself.</p>
<p>To avoid exceptions being lost package defines default callback for unhandled failures that logs errors to <tt class="docutils literal">logging.error</tt> by default. You can override this behavior by setting <tt class="docutils literal">config.Default.UNHANDLED_FAILURE_CALLBACK</tt> field on application startup.</p>
<p>It is possible to ignore errors explicitly using <tt class="docutils literal">f.recover(None)</tt>.</p>
</div>
<div class="section" id="compatibility-between-different-types-of-futures">
<h2><a class="toc-backref" href="#id12">Compatibility between different types of futures</a></h2>
<p>For applications which may use both cooperative and multithreaded concurrency models at the same time there's a high risk of mixing different future types in composition methods. If this goes unnoticed it may result in race conditions.</p>
<p>To prevent this, all composition methods of <tt class="docutils literal">FutureBaseExt</tt> perform type checking, raising <tt class="docutils literal">TypeError</tt> when class which was used for calling composition method does not match with class of <tt class="docutils literal">Future</tt> instances. This check is performed by <tt class="docutils literal">FutureBaseExt.convert(future)</tt> method.</p>
<p>However this restriction is too strict. For example it is safe to use callbacks of <tt class="docutils literal">cooperative.Future</tt> in composition methods of <tt class="docutils literal">multithreaded.Future</tt>. Also <tt class="docutils literal">multithreaded.Future</tt> can be easily wrapped into <tt class="docutils literal">asyncio.Future</tt> by using <tt class="docutils literal">loop.call_soon_threadsafe()</tt> method. To allow such compatibility and conversions <tt class="docutils literal">multithreaded.Future</tt> and <tt class="docutils literal">asyncio.Future</tt> override <tt class="docutils literal">convert(future)</tt> method.</p>
<p>Resulting conversions are:</p>
<ul class="simple">
<li><tt class="docutils literal">multithreaded.Future</tt> compatible with all subclasses of <tt class="docutils literal">concurrent.Future</tt></li>
<li><tt class="docutils literal">asyncio.Future</tt> compatible with all subclasses of itself (<tt class="docutils literal">asyncio.Task</tt>)</li>
<li><tt class="docutils literal">asyncio.Future</tt> converts subclasses of <tt class="docutils literal">multithreaded.Future</tt> via wrapping</li>
</ul>
<p>As a result, this compatibility mechanism allows mixing futures of different types and nature in composition methods safely.</p>
</div>
</div>
<div class="section" id="usage-examples">
<h1><a class="toc-backref" href="#id13">Usage examples</a></h1>
<div class="section" id="computations">
<h2><a class="toc-backref" href="#id14">Computations</a></h2>
<pre class="literal-block">
from concurrent.futures.multithreaded import Future
from concurrent.executors import ThreadPoolExecutor

with ThreadPoolExecutor(10) as tp:
        def sqr(x):
                return x * x

        fsquares = [tp.submit(sqr, v) for v in range(10)]
        fsum = Future.all(fsquares).map(sum)

        print(fsum.result())
</pre>
</div>
<div class="section" id="chaining-requests">
<h2><a class="toc-backref" href="#id15">Chaining requests</a></h2>
<pre class="literal-block">
from concurrent.futures.multithreaded import Future

def authenticate_async(login, pwd):
        return Future.successful(True)

def request_async(request):
        return Future.successful(request)

fauth = authenticate_async('john', 'swordfish')
frequest = fauth.then(lambda: request_async('echo'))

resul = yieldfrequest.on_success(lambda resp: print(&quot;auth and request successful: &quot; + resp))
frequest.on_failure(lambda ex: print(&quot;auth or request failed&quot;))
</pre>
</div>
<div class="section" id="fallbacks">
<h2><a class="toc-backref" href="#id16">Fallbacks</a></h2>
<pre class="literal-block">
from concurrent.futures.multithreaded import Future

def connect_ssl():
        return Future.failed(SocketError())

def connect_plain():
        return Future.successful('socket')

fconnection = connect_ssl().fallback(connect_plain)
</pre>
</div>
<div class="section" id="hedged-requests">
<h2><a class="toc-backref" href="#id17">Hedged requests</a></h2>
<pre class="literal-block">
import asyncio
import random

def request(ip):
        yield from asyncio.sleep(random.random())
        if random.choice([True, False]):
                return &quot;ok&quot;
        raise Exception(&quot;fail&quot;)

IPs = ['ip1', 'ip2', 'ip3', 'ip4', 'ip5']
futures = [asyncio.Task(request(ip)) for ip in IPs]
response = yield from asyncio.Future.first_successful(futures)
print(response)
</pre>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id18">Backward compatibility</a></h1>
<div class="section" id="interface-differences">
<h2><a class="toc-backref" href="#id19">Interface differences</a></h2>
<p><tt class="docutils literal">concurrent.futures.Future</tt></p>
<blockquote>
Class is deprecated in favor of <tt class="docutils literal">concurrent.futures.multithreaded.Future</tt>.</blockquote>
<p><tt class="docutils literal">running()</tt></p>
<blockquote>
Left for compatibility but always returns <tt class="docutils literal">False</tt>.</blockquote>
<p><tt class="docutils literal">set_running_or_notify_cancel()</tt></p>
<blockquote>
Left for compatibility but simply returns <tt class="docutils literal">cancelled()</tt> result.</blockquote>
<p>Module functions differences:</p>
<p><tt class="docutils literal">concurrent.futures.wait()</tt></p>
<p><tt class="docutils literal">concurrent.futures.as_completed()</tt></p>
<p><tt class="docutils literal">asyncio.wait()</tt></p>
<p><tt class="docutils literal">asyncio.gather()</tt></p>
<blockquote>
Function are deprecated in favor of combination methods and use them internally.</blockquote>
<p><tt class="docutils literal">asyncio.wrap_future()</tt></p>
<blockquote>
Deprecated in favor of <tt class="docutils literal">Future.convert(future)</tt>, all composition methods perform this conversion automatically.</blockquote>
<p>Concrete implementations of schedulers are considered to be beyond the scope of <tt class="docutils literal">concurrent.futures</tt> module, so they are moved into <tt class="docutils literal">concurrent.schedulers</tt> sub-package. For backward compatibility <tt class="docutils literal">ThreadPoolExecutor</tt> and <tt class="docutils literal">ProcessPoolExecutor</tt> are still accessible from <tt class="docutils literal">concurrent.futures</tt> package.</p>
</div>
</div>
<div class="section" id="further-development">
<h1><a class="toc-backref" href="#id20">Further development</a></h1>
<ul class="simple">
<li><tt class="docutils literal">Observable</tt> abstraction for asynchronous streams of data.</li>
<li>ThreadPool-based scheduler allowing non-blocking future cancellation by timeout.</li>
<li>Debugging facilities for tracing and graphing future chains.</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<ul class="simple">
<li><a class="reference external" href="/dev/peps/pep-3148">PEP 3148</a> describes current implementation of <tt class="docutils literal">concurrent.futures</tt></li>
<li><a class="reference external" href="/dev/peps/pep-3156">PEP 3156</a> describes <tt class="docutils literal">asyncio</tt> package implementing own futures</li>
</ul>
</div>

